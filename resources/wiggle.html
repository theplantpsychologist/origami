<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wiggler</title>
    <link rel="stylesheet" type = "text/css" href="../style.css">
</head>
<body>
    <div id='wrapper'>
        <div id='head'>
            <a id = "name" href="../index.html"><img src="../img/logo.svg" style="width: 50%;" alt="logo"></a>
            <hr>
            <div id='navigator'>
                <a class="navlink" href="../index.html">Home</a>
                <a class="navlink" href="../about.html">Origami</a>
                <a class="navlink" href="../resources.html">Resources</a>
                <a class="navlink" href="../other.html">Other</a>
            </div>
        </div>
        <hr>
        <h1>Messy cp wiggler</h1>
        <div>
            <noscript>Please enable javascript to use this app.</noscript>
            <p>
                <b>How to use:</b> upload a .cp file, make it messy, and see if it can clean it up. Click upload again to reset.
            </p>
            <div>
                
                <input type="file" id="inputfile" name="inputfile" value="example.cp" />
                <pre id="output"></pre>
                <script>
                    function UploadCp() {
                        const reader = new FileReader();
                        reader.onload = function () {
                            input = reader.result;
                            cp = start(input);
                        };
                        const fileSelector = document.getElementById("inputfile");
                        if (fileSelector) {
                            reader.readAsText(fileSelector.files[0]);
                        } else {
                            console.log("File input element not present");
                        }
                    }
                </script>
                <button id="upload" type=button onclick="UploadCp()">Upload</button>


            </div>
        </div>

        <div>
            <button type = button onclick="cp = messy(cp)">Add noise</button>
            <button type = button onclick="cp = cleanup(cp)">Clean up once</button>
            <button type = button onclick="cp = cleanupAll(cp)">Clean up until completely fixed</button>
        </div>
        <div>
            <p>Noise Constant</p>
            <input type="text" id="noiseConstant" value="0.5">
            <p>Learning rate</p>
            <input type="text" id="learningRate" value="0.01">
        </div>
        <hr>
        <canvas id="square" width="800" height = "900"></canvas>
        <script src="paper-core.js"></script>
        <script src="origami.js"></script> 
        <script src="example.js"></script>
        <script>
            noisyCp = `1 -200.0 -200.0 -200.0 -80.0
1 -200.0 -200.0 -66.66666666666663 -200.0
1 200.0 200.0 160.00000000000009 200.0
1 200.0 200.0 200.0 160.0
1 -0.0 200.0 -66.66666666666666 200.0
1 -200.0 0.0 -200.0 66.66666666666666
1 2.4492935982947067E-14 -200.0 66.66666666666673 -200.0
1 -200.0 -80.0 -200.0 -66.66666666666669
1 -200.0 80.0 -200.0 200.0
1 200.0 26.66666666666675 200.0 0.0
1 -160.0 200.0 -200.0 200.0
1 200.0 160.0 199.99999999999997 80.0
1 200.00000000000003 -160.0 200.0 -200.0
1 200.0 0.0 200.0 -66.66666666666669
1 199.99999999999997 80.0 199.99999999999994 66.66666666666664
1 160.00000000000009 200.0 66.66666666666667 200.0
2 -66.66666666666666 200.0 -66.66666666666664 66.66666666666666
1 -66.66666666666663 -200.0 2.4492935982947067E-14 -200.0
1 -66.66666666666666 200.0 -160.0 200.0
3 66.66666666666671 -200.0 66.6666666666667 -66.66666666666669
1 66.66666666666673 -200.0 200.0 -200.0
1 66.66666666666667 200.0 -0.0 200.0
3 200.00000000000003 -66.66666666666669 66.6666666666667 -66.66666666666669
1 -200.0 -66.66666666666669 -200.0 0.0
1 200.0 -66.66666666666669 200.00000000000003 -160.0
3 -66.66666666666664 -66.66666666666669 -199.99999999999997 -66.66666666666669
2 -66.66666666666664 -66.66666666666669 -66.66666666666663 -200.0
2 66.6666666666667 -66.66666666666669 -66.66666666666664 -66.66666666666669
3 66.6666666666667 -66.66666666666669 66.6666666666667 66.66666666666666
2 -200.0 66.66666666666666 -66.66666666666664 66.66666666666666
1 -200.0 66.66666666666666 -200.0 80.0
1 199.99999999999994 66.66666666666664 200.0 26.66666666666675
3 -66.66666666666664 66.66666666666666 66.6666666666667 66.66666666666666
2 -66.66666666666664 66.66666666666666 -66.66666666666664 -66.66666666666669
2 66.6666666666667 66.66666666666666 200.0 66.66666666666666
3 66.6666666666667 66.66666666666666 66.66666666666669 200.0

`
        </script>

        <script type="text/javascript" data-paper-ignore="true">
            paper.setup(document.getElementById("square"))

            var cp
            var displaycp1 = new paper.Group();
            var displaycp2 = new paper.Group();

            function start(input){
                var cp =  readCpFile(input)
                //cp.foldXray()
                displaycp1.clear();
                displaycp2.clear();
                displaycp1 = displayCp(cp,10,5,390,385)
                return cp
            }

            function messy(cp){
                for(const vertex of cp.vertices){
                    const noise = parseFloat(noiseConstant.value)
                    vertex.x += (Math.random() - 0.5) * vertex.x*(1-vertex.x) * noise
                    vertex.y += (Math.random() - 0.5) * vertex.y*(1-vertex.y) * noise
                }
                for(const vertex of cp.vertices){
                    isVertexFlatFoldable(vertex)
                }
                displaycp1.clear();
                displaycp1 = displayCp(cp,10,5,390,385)

                error = 0
                for(const vertex of cp.vertices){
                    //Each term of the error function corresponds to the squared kawasaki error of a non-edge vertex
                    //
                    if(eq(vertex.x*(1-vertex.x)*vertex.y*(1-vertex.y),0)){continue}
                    var kawasaki = 0
                    for(i = 0; i<vertex.sectors.length; i++){
                        kawasaki += (-1)**i * vertex.sectors[i]
                    }
                    error += kawasaki**2
                }
                console.log('Error',error)
                return cp
            }

            function cleanup(cp){
                for(const vertex of cp.vertices){
                    isVertexFlatFoldable(vertex)
                }
                const alpha = parseFloat(learningRate.value) //learning rate
                //x = x-dx
                //dx = alpha * the partial derivative of the cost function, with respect to x
                //in other words, the partial derivative is how much error is produced by a given dx

                //The cost function is the sum of all the kawasaki errors squared.
                //Go through each term of the cost function, and within each term, take the partial with respect to all of its variables
                    //and add to the respective dy or dx
                //At the end, each coordinate will subtract the dy or dx, times the learning rate

                for(const vertex of cp.vertices){vertex.dx = 0; vertex.dy = 0} //initialize
                for(const vertex of cp.vertices){
                    //Each term of the error function corresponds to the squared kawasaki error of a non-edge vertex
                    //
                    if(eq(vertex.x*(1-vertex.x)*vertex.y*(1-vertex.y),0)){continue}
                    var error = 0
                    for(i = 0; i<vertex.sectors.length; i++){error += (-1)**i * vertex.sectors[i]}//really this will be squared when added to the cost function
                    if(eq(error,0)){continue}

                    var i = 0 //for the alternating + -
                    for(const crease of vertex.creases){
                        var otherVertex = crease.vertices[crease.vertices[0]==vertex?1:0]
                        var deltaX = otherVertex.x - vertex.x
                        var deltaY = otherVertex.y - vertex.y
                        //take partial derivatives
                        otherVertex.dx  += (2*error) * deltaY / (-1*(deltaX)**2 * (1+(deltaY/deltaX)**2))   *(-1)**i
                        vertex.dx       -= (2*error) * deltaY / (-1*(deltaX)**2 * (1+(deltaY/deltaX)**2))   *(-1)**i
                        otherVertex.dy  += (2*error) * deltaY / (deltaX * (1+(deltaY/deltaX)**2))           *(-1)**i
                        vertex.dy       -= (2*error) * deltaY / (deltaX * (1+(deltaY/deltaX)**2))           *(-1)**i
                        i++
                    }
                }
                for(const vertex of cp.vertices){
                    if(!eq(vertex.x*(1-vertex.x),0) | isNaN(vertex.dx)){vertex.x -= vertex.dx*alpha} 
                    if(!eq(vertex.y*(1-vertex.y),0) | isNaN(vertex.dy)){vertex.y -= vertex.dy*alpha}
                }
                displaycp2.clear()
                displaycp2 = displayCp(cp,410,5,790,385)
                return cp
            }

            function cleanupAll(cp){
                var stopper = 0;
                while(stopper<500){
                    if(checkLocalFlatFoldability(cp)){console.log("looks pretty good");return cp}
                    cp = cleanup(cp)
                    stopper++
                }
                console.log("tried",stopper,"times")
                return cp
            }
            
            start(noisyCp)
        </script>

        <div>
            <h2>Notes about this program</h2>
            <p><b>How it works:</b> Gradient descent
        </div>
    </div>
</body>
</html>